<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebDrop</title>
    <!-- PWA Settings -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#0f172a">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Premium Midnight Theme */
            --bg-main: #020617;
            --bg-card: #0f172a;
            --text-main: #f8fafc;
            --text-sub: #94a3b8;
            --primary: #3b82f6;
            --primary-glow: rgba(59, 130, 246, 0.5);
            --accent: #10b981;
            --border: #1e293b;
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background-color: var(--bg-main);
            color: var(--text-main);
            margin: 0;
            min-height: 100dvh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1.5rem;
            /* Allow scroll if card gets tall */
            overflow-y: auto;
        }

        /* Modern Card */
        .glass-card {
            background-color: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 32px;
            padding: 3rem;
            width: 100%;
            max-width: 420px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            position: relative;
            transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            text-align: center;
            /* Centers inline-block elements like QR */
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 800;
            margin: 0 0 0.5rem 0;
            text-align: center;
            letter-spacing: -0.04em;
            background: linear-gradient(to right, #60a5fa, #a78bfa);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        p {
            color: var(--text-sub);
            text-align: center;
            margin-bottom: 2.5rem;
            line-height: 1.6;
            font-size: 0.95rem;
            font-weight: 500;
        }

        /* Input & Button */
        .input-group {
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
            margin-bottom: 1.5rem;
        }

        input {
            background: #1e293b;
            border: 1px solid var(--border);
            padding: 1.25rem;
            border-radius: 20px;
            color: white;
            font-size: 1.1rem;
            font-weight: 600;
            outline: none;
            text-align: center;
            transition: all 0.2s;
            width: 100%;
            letter-spacing: 0.05em;
        }

        input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.1);
            background: #25334d;
        }

        .btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 1.25rem;
            border-radius: 20px;
            font-weight: 700;
            font-size: 1.05rem;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 10px 15px -3px var(--primary-glow);
            width: 100%;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 20px 25px -5px var(--primary-glow);
        }

        .btn:active {
            transform: scale(0.98);
        }

        .icon-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: var(--text-sub);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            transition: all 0.2s;
        }

        .icon-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            transform: rotate(90deg);
        }

        .delete-btn {
            width: 32px;
            height: 32px;
            font-size: 1rem;
            background: transparent;
            color: #ef4444;
        }

        .delete-btn:hover {
            background: rgba(239, 68, 68, 0.2);
            color: #f87171;
            transform: none;
            /* No rotation for trash */
        }

        /* Drop Zone */
        .drop-zone {
            border: 2px dashed var(--border);
            border-radius: 24px;
            padding: 3rem 1.5rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.01);
            position: relative;
            overflow: hidden;
        }

        .drop-zone:hover {
            background: rgba(255, 255, 255, 0.03);
            border-color: var(--text-sub);
        }

        .drop-zone.dragover {
            background: rgba(59, 130, 246, 0.1);
            border-color: var(--primary);
            transform: scale(1.02);
        }

        .icon-large {
            font-size: 4rem;
            margin-bottom: 1rem;
            display: block;
            opacity: 0.8;
            filter: drop-shadow(0 0 20px rgba(255, 255, 255, 0.1));
        }

        /* File List */
        .file-list {
            margin-top: 2rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            /* Allow list to grow, but keep it scrollable if very long */
            max-height: 400px;
            overflow-y: auto;
            padding-right: 6px;
        }

        .file-list::-webkit-scrollbar {
            width: 4px;
        }

        .file-list::-webkit-scrollbar-thumb {
            background: #334155;
            border-radius: 4px;
        }

        .file-item {
            background: #1e293b;
            border: 1px solid var(--border);
            border-radius: 18px;
            padding: 1.25rem;
            display: flex;
            align-items: center;
            gap: 1rem;
            animation: slideUp 0.4s cubic-bezier(0.16, 1, 0.3, 1);
        }

        .file-icon {
            font-size: 1.5rem;
            background: #334155;
            width: 48px;
            height: 48px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 14px;
            color: #94a3b8;
        }

        .file-info {
            flex: 1;
            min-width: 0;
            /* Critical for text-overflow to work in flex child */
            margin-right: 0.5rem;
        }

        .file-name {
            font-weight: 600;
            font-size: 0.95rem;
            display: block;
            margin-bottom: 4px;
            color: #f1f5f9;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .file-size {
            font-size: 0.85rem;
            color: var(--text-sub);
            font-weight: 500;
        }

        .file-actions {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-shrink: 0;
        }

        .download-btn {
            background: var(--accent);
            color: #022c22;
            padding: 0.6rem 1rem;
            border-radius: 12px;
            text-decoration: none;
            font-size: 0.85rem;
            font-weight: 700;
            transition: transform 0.2s;
            white-space: nowrap;
        }

        .download-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }

        /* Progress - Slim & Sexy */
        .progress-container {
            width: 100%;
            height: 4px;
            background: #334155;
            border-radius: 2px;
            margin-top: 0.75rem;
            overflow: hidden;
            display: none;
        }

        .progress-bar {
            height: 100%;
            background: var(--primary);
            width: 0%;
            transition: width 0.2s ease-out;
            box-shadow: 0 0 10px var(--primary);
        }

        /* Screen States */
        .screen {
            display: none;
            width: 100%;
        }

        .screen.active {
            display: block;
            animation: fadeIn 0.6s cubic-bezier(0.16, 1, 0.3, 1);
        }

        /* Status Badge - Floating Capsule */
        .status-badge {
            position: fixed;
            top: 1.5rem;
            right: 1.5rem;
            background: #1e293b;
            padding: 0.5rem 1rem;
            border-radius: 999px;
            font-size: 0.85rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 100;
            border: 1px solid var(--border);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            background: #ef4444;
            border-radius: 50%;
            transition: all 0.3s;
        }

        .status-dot.connected {
            background: #10b981;
            box-shadow: 0 0 12px #10b981;
        }

        /* Animations */
        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.98);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* Mobile */
        @media (max-width: 600px) {
            body {
                padding: 1rem;
                justify-content: flex-start;
                padding-top: 5rem;
            }

            .glass-card {
                padding: 2rem 1.5rem;
                border-radius: 24px;
            }

            h1 {
                font-size: 2rem;
            }

            .icon-large {
                font-size: 3.5rem;
            }
        }
    </style>
    <link rel="icon" href="icon.svg" type="image/svg+xml">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
</head>

<body>

    <div class="status-badge" id="statusBadge" style="display:none;">
        <div class="status-dot" id="statusDot"></div>
        <span id="statusText">Disconnected</span>
    </div>

    <!-- Login Screen -->
    <div id="loginScreen" class="glass-card screen active">
        <h1>WebDrop</h1>
        <p>Simple, Secure P2P File Transfer<br>No Server Storage, Direct Device-to-Device</p>

        <div id="qrContainer"
            style="text-align: center; margin-bottom: 20px; padding: 10px; background: white; border-radius: 12px; display: inline-block;">
            <!-- QR Code will be generated here -->
            <div id="qrcode"></div>
        </div>
        <p style="font-size: 0.8rem; margin-top: -10px;">Scan to Connect</p>

        <div class="input-group">
            <input type="text" id="roomIdInput" placeholder="Enter Room ID (e.g. 1234)" autocomplete="off">
            <button class="btn" onclick="joinRoom()">Join Room</button>
        </div>
        <p style="font-size: 0.8rem;">Share the Room ID with your peer to connect.</p>
    </div>

    <!-- Main Transfer Screen -->
    <div id="transferScreen" class="glass-card screen">
        <div style="position: absolute; top: 1.5rem; left: 1.5rem;">
            <button onclick="leaveRoom()" class="icon-btn" title="Leave Room">‚úï</button>
        </div>
        <h1>Transfer</h1>
        <p>Connected to Room: <strong id="currentRoomDisplay" style="color: #fff;">...</strong></p>

        <div class="drop-zone" id="dropZone" onclick="document.getElementById('fileInput').click()">
            <span class="icon-large">‚òÅÔ∏è</span>
            <h3>Tap or Drag Files Here (or Ctrl+V)</h3>
            <p>Support any file type (PDF, ZIP, IMG...)</p>
            <input type="file" id="fileInput" style="display: none;" multiple>
        </div>

        <!-- Sending Progress -->
        <div id="sendProgress" style="margin-top: 1.5rem; display: none;">
            <div style="display: flex; justify-content: space-between; font-size: 0.9rem;">
                <span id="sendingFileName">Sending...</span>
                <span id="sendPercentage">0%</span>
            </div>
            <div class="progress-container" style="display: block;">
                <div class="progress-bar" id="sendProgressBar"></div>
            </div>
        </div>

        <!-- Received Files List -->
        <h3 id="filesHeader"
            style="display:none; text-align: left; margin-top: 2rem; margin-bottom: 0.5rem; font-size: 1.1rem;">Received
            Files</h3>
        <div id="fileList" class="file-list">
            <!-- Items added dynamically -->
        </div>
    </div>

    <!-- QR Code Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

    <script>
        // CONFIG
        const HOST_IP = "{{ host_ip }}"; // Injected by server
        const CHUNK_SIZE = 64 * 1024; // 64KB chunks
        const STUN_SERVER = { urls: 'stun:stun.l.google.com:19302' };

        let socket;
        let peer;
        let dataChannel;
        let roomId;
        let reconnectTimer = null;

        // Queue
        let fileQueue = [];
        let isSending = false;

        // Receiving logic
        let incomingFileInfo = null;
        let receivedBuffers = [];
        let receivedSize = 0;

        // Init Logic
        window.onload = () => {
            if (!document.getElementById('roomIdInput').value) {
                const urlParams = new URLSearchParams(window.location.search);
                const roomParam = urlParams.get('room');
                if (roomParam) {
                    document.getElementById('roomIdInput').value = roomParam;
                } else {
                    document.getElementById('roomIdInput').value = Math.floor(1000 + Math.random() * 9000);
                }
            }
            generateQR();
            document.getElementById('roomIdInput').addEventListener('input', generateQR);

            // Paste Event Listener (Global)
            document.addEventListener('paste', handlePaste);
        };

        function generateQR() {
            const rid = document.getElementById('roomIdInput').value || "";
            const port = window.location.port ? ":" + window.location.port : "";
            const url = `http://${HOST_IP}${port}/?room=${rid}`;

            document.getElementById('qrcode').innerHTML = "";
            new QRCode(document.getElementById("qrcode"), {
                text: url,
                width: 128,
                height: 128,
                colorDark: "#000000",
                colorLight: "#ffffff",
                correctLevel: QRCode.CorrectLevel.H
            });
        }

        // Paste Handler
        function handlePaste(e) {
            const items = (e.clipboardData || e.originalEvent.clipboardData).items;
            for (let i = 0; i < items.length; i++) {
                if (items[i].type.indexOf("image") !== -1) {
                    const blob = items[i].getAsFile();
                    // Generate a name (since clipboard files are often "image.png")
                    const date = new Date();
                    const filename = `screenshot_${date.getHours()}${date.getMinutes()}${date.getSeconds()}.png`;
                    const file = new File([blob], filename, { type: blob.type });

                    // Trigger send
                    if (document.getElementById('transferScreen').classList.contains('active')) {
                        handleFiles([file]);
                    } else {
                        alert("Join a room first to paste and send!");
                    }
                }
            }
        }

        /* --- UI Logic --- */
        function joinRoom() {
            roomId = document.getElementById('roomIdInput').value.trim();
            if (!roomId) {
                alert("Please enter a Room ID.");
                return;
            }

            // Sync URL
            const url = new URL(window.location);
            url.searchParams.set('room', roomId);
            window.history.pushState({}, '', url);

            document.getElementById('loginScreen').classList.remove('active');
            document.getElementById('transferScreen').classList.add('active');
            document.getElementById('statusBadge').style.display = 'flex';
            document.getElementById('currentRoomDisplay').innerText = roomId;

            initWebSocket();
        }

        function leaveRoom() {
            if (confirm("Disconnect and leave room?")) {
                // Close Connections
                if (peer) { peer.close(); peer = null; }
                if (socket) { socket.close(); socket = null; }
                if (reconnectTimer) { clearInterval(reconnectTimer); reconnectTimer = null; }

                // Reset UI
                document.getElementById('statusBadge').style.display = 'none';
                document.getElementById('transferScreen').classList.remove('active');
                document.getElementById('loginScreen').classList.add('active');

                // Clear URL param
                const url = new URL(window.location);
                url.searchParams.delete('room');
                window.history.pushState({}, '', url);

                // Clear status
                updateStatus('disconnected');
            }
        }

        function updateStatus(state) {
            const dot = document.getElementById('statusDot');
            const text = document.getElementById('statusText');
            if (state === 'connected') {
                dot.classList.add('connected');
                text.innerText = 'P2P Connected';
            } else if (state === 'waiting') {
                dot.classList.remove('connected');
                dot.style.background = '#f59e0b';
                text.innerText = 'Waiting for Peer...';
            } else if (state === 'reconnecting') {
                dot.classList.remove('connected');
                dot.style.background = '#f59e0b';
                text.innerText = 'Reconnecting...';
            } else {
                dot.classList.remove('connected');
                dot.style.background = '#ef4444';
                text.innerText = 'Disconnected';
            }
        }

        /* --- WebSocket & Signaling --- */
        function initWebSocket() {
            if (socket && socket.readyState === WebSocket.OPEN) return;

            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const host = window.location.host;
            const url = `${protocol}//${host}/ws/${roomId}`;

            console.log(`Connecting to WS: ${url}`);
            socket = new WebSocket(url);

            socket.onopen = () => {
                console.log("WS Connected");
                updateStatus('waiting');
                if (reconnectTimer) {
                    clearInterval(reconnectTimer);
                    reconnectTimer = null;
                }
                startPeerConnection();
            };

            socket.onclose = () => {
                console.log("WS Closed. Reconnecting in 3s...");
                updateStatus('reconnecting');
                if (peer) {
                    peer.close();
                    peer = null;
                }
                // Auto reconnect
                if (!reconnectTimer) {
                    reconnectTimer = setInterval(() => initWebSocket(), 3000);
                }
            };

            socket.onerror = (e) => {
                console.log("WS Error", e);
                socket.close();
            };

            socket.onmessage = async (event) => {
                const msg = JSON.parse(event.data);
                if (!peer) startPeerConnection();

                try {
                    if (msg.sdp) {
                        await peer.setRemoteDescription(new RTCSessionDescription(msg.sdp));
                        if (msg.sdp.type === 'offer') {
                            const answer = await peer.createAnswer();
                            await peer.setLocalDescription(answer);
                            socket.send(JSON.stringify({ sdp: answer }));
                        }
                    } else if (msg.candidate) {
                        await peer.addIceCandidate(new RTCIceCandidate(msg.candidate));
                    }
                } catch (e) {
                    console.error("Signaling Error:", e);
                }
            };
        }

        /* --- WebRTC Core --- */
        function startPeerConnection() {
            if (peer) return;

            peer = new RTCPeerConnection({ iceServers: [STUN_SERVER] });

            peer.onicecandidate = (e) => {
                if (e.candidate && socket.readyState === WebSocket.OPEN) {
                    socket.send(JSON.stringify({ candidate: e.candidate }));
                }
            };

            peer.onconnectionstatechange = () => {
                console.log("P2P State:", peer.connectionState);
                if (peer.connectionState === 'connected') {
                    updateStatus('connected');
                } else if (peer.connectionState === 'disconnected' || peer.connectionState === 'failed') {
                    updateStatus('waiting');
                    peer.close();
                    peer = null;
                }
            };

            peer.ondatachannel = (e) => {
                setupDataChannel(e.channel);
            };

            dataChannel = peer.createDataChannel("file-transfer");
            setupDataChannel(dataChannel);

            peer.createOffer().then(async (offer) => {
                await peer.setLocalDescription(offer);
                if (socket.readyState === WebSocket.OPEN) {
                    socket.send(JSON.stringify({ sdp: offer }));
                }
            }).catch(e => console.log("Did not create offer (negotiation ongoing)"));
        }

        function setupDataChannel(channel) {
            dataChannel = channel;
            dataChannel.binaryType = 'arraybuffer';
            dataChannel.onopen = () => {
                updateStatus('connected');
                processQueue();
            };
            dataChannel.onmessage = handleDataMessage;
        }

        /* --- File Transfer Logic --- */
        const dropZone = document.getElementById('dropZone');

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });
        dropZone.addEventListener('dragleave', (e) => {
            dropZone.classList.remove('dragover');
        });
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            handleFiles(e.dataTransfer.files);
        });

        document.getElementById('fileInput').addEventListener('change', (e) => {
            handleFiles(e.target.files);
        });

        function handleFiles(files) {
            for (let i = 0; i < files.length; i++) {
                fileQueue.push(files[i]);
            }
            processQueue();
        }

        // 2. Sending (Streaming Mode)
        async function processQueue() {
            if (isSending || fileQueue.length === 0) return;
            if (!dataChannel || dataChannel.readyState !== 'open') return;

            isSending = true;
            const file = fileQueue.shift();
            await sendFileStreaming(file);
            isSending = false;
            processQueue();
        }

        async function sendFileStreaming(file) {
            const progressBar = document.getElementById('sendProgressBar');
            const progressText = document.getElementById('sendPercentage');
            const fileNameLabel = document.getElementById('sendingFileName');

            document.getElementById('sendProgress').style.display = 'block';
            fileNameLabel.innerText = `Sending: ${file.name}`;
            progressBar.style.width = '0%';

            dataChannel.send(JSON.stringify({
                type: 'meta',
                name: file.name,
                size: file.size,
                mime: file.type
            }));

            let offset = 0;
            while (offset < file.size) {
                // If channel closes mid-transfer, stop
                if (dataChannel.readyState !== 'open') break;

                const slice = file.slice(offset, offset + CHUNK_SIZE);
                const buffer = await slice.arrayBuffer();

                if (dataChannel.bufferedAmount > 16 * 1024 * 1024) {
                    await new Promise(r => setTimeout(r, 50));
                }

                try {
                    dataChannel.send(buffer);
                } catch (e) {
                    console.error("Send Error", e);
                    break;
                }

                offset += buffer.byteLength;

                // Yield to event loop more frequently to prevent UI freeze (every 320KB -> every chunk)
                // Using 0ms timeout ensures the browser renders frame updates
                await new Promise(r => setTimeout(r, 0));

                // Update progress every few chunks to avoid DOM thrashing too much, but keep loop responsive
                if (offset % (CHUNK_SIZE * 2) === 0 || offset >= file.size) {
                    const percent = Math.floor((offset / file.size) * 100);
                    progressBar.style.width = `${percent}%`;
                    progressText.innerText = `${percent}%`;
                }
            }

            console.log("File sent:", file.name);
            document.getElementById('sendProgress').style.display = 'none';
        }

        // 3. Receiving
        function handleDataMessage(event) {
            const data = event.data;

            if (typeof data === 'string') {
                const msg = JSON.parse(data);
                if (msg.type === 'meta') {
                    incomingFileInfo = msg;
                    receivedBuffers = [];
                    receivedSize = 0;
                    createReceivingItem(msg.name, msg.size);
                }
            } else {
                if (!incomingFileInfo) return;

                receivedBuffers.push(data);
                receivedSize += data.byteLength;

                updateReceiveProgress(receivedSize, incomingFileInfo.size);

                if (receivedSize >= incomingFileInfo.size) {
                    finalizeDownload();
                }
            }
        }

        let currentReceiveBar = null;

        function createReceivingItem(name, size) {
            document.getElementById('filesHeader').style.display = 'block';
            const list = document.getElementById('fileList');
            const div = document.createElement('div');
            div.className = 'file-item';

            const sizeStr = (size / (1024 * 1024)).toFixed(2) + ' MB';

            div.innerHTML = `
                <div class="file-icon">üìÑ</div>
                <div class="file-info">
                    <span class="file-name" title="${name}">${name}</span>
                    <span class="file-size">${sizeStr}</span>
                    <div class="progress-container" style="display:block">
                        <div class="progress-bar" style="width: 0%"></div>
                    </div>
                </div>
                <!-- Actions Wrapper -->
                <div class="file-actions">
                    <!-- Download button will be injected here -->
                    <button class="icon-btn delete-btn" onclick="this.closest('.file-item').remove()" title="Remove">
                        üóëÔ∏è
                    </button>
                </div>
            `;
            list.prepend(div);
            currentReceiveBar = div.querySelector('.progress-bar');
        }

        function updateReceiveProgress(current, total) {
            if (currentReceiveBar) {
                const percent = Math.floor((current / total) * 100);
                currentReceiveBar.style.width = `${percent}%`;
            }
        }

        function finalizeDownload() {
            const blob = new Blob(receivedBuffers, { type: incomingFileInfo.mime });
            const url = URL.createObjectURL(blob);

            if (currentReceiveBar) {
                const fileItem = currentReceiveBar.closest('.file-item');
                const actionsDiv = fileItem.querySelector('.file-actions');
                const progressContainer = currentReceiveBar.parentElement;

                // Hide progress bar
                progressContainer.style.display = 'none';

                const btn = document.createElement('a');
                btn.href = url;
                btn.download = incomingFileInfo.name;
                btn.className = 'download-btn';
                btn.innerText = 'Download';
                btn.onclick = () => { setTimeout(() => URL.revokeObjectURL(url), 60000); };

                // Insert Download button BEFORE the delete button
                actionsDiv.insertBefore(btn, actionsDiv.firstChild);
            }

            receivedBuffers = [];
            incomingFileInfo = null;
            currentReceiveBar = null;
            console.log("Download ready");
        }
    </script>
</body>

</html>